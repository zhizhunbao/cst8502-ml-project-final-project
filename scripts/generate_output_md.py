"""
Script to run TrafficViolationAnalysis.py and capture output to Markdown file
with embedded visualizations at the correct positions
"""
import sys
import os
import io
from contextlib import redirect_stdout
from datetime import datetime
import matplotlib
matplotlib.use('Agg')  # Use non-interactive backend
import matplotlib.pyplot as plt

# Add parent directory to path to import TrafficViolationAnalysis
script_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(script_dir)
if parent_dir not in sys.path:
    sys.path.insert(0, parent_dir)

# Track saved figures
figure_positions = []  # List of figure paths
IMAGES_DIR = 'images'  # Relative to project root

class OutputTracker:
    """Track output and insert figure markers"""
    def __init__(self):
        self.buffer = io.StringIO()
        self.figure_count = 0
    
    def write(self, text):
        """Write to buffer"""
        return self.buffer.write(text)
    
    def getvalue(self):
        """Get buffer value"""
        return self.buffer.getvalue()
    
    def insert_figure_marker(self, fig_path):
        """Insert a marker for figure insertion"""
        self.figure_count += 1
        marker = f"\n\n<!-- FIGURE_MARKER_{self.figure_count}:{fig_path} -->\n"
        self.buffer.write(marker)
        return marker

def save_figure_wrapper(original_show, output_tracker):
    """Wrapper to save figures before showing and insert marker"""
    def wrapper(*args, **kwargs):
        # Save the current figure if it exists
        if plt.get_fignums():
            # Ensure images directory exists in project root
            images_path = os.path.join(parent_dir, IMAGES_DIR)
            os.makedirs(images_path, exist_ok=True)
            
            fig_num = len(figure_positions) + 1
            filename = os.path.join(images_path, f'figure_{fig_num:02d}.png')
            plt.savefig(filename, dpi=150, bbox_inches='tight')
            
            # Store relative path
            fig_path = os.path.join(IMAGES_DIR, f'figure_{fig_num:02d}.png')
            figure_positions.append(fig_path)
            
            # Insert marker in output
            output_tracker.insert_figure_marker(fig_path)
        # Call original show (which won't display anything with Agg backend)
        return original_show(*args, **kwargs)
    return wrapper

def generate_markdown_output():
    """Run the analysis script and capture output to markdown with figures"""
    global figure_positions
    figure_positions = []
    
    # Change to parent directory to run the script
    original_cwd = os.getcwd()
    os.chdir(parent_dir)
    
    # Create output tracker
    output_tracker = OutputTracker()
    
    # Patch plt.show to save figures
    original_show = plt.show
    plt.show = save_figure_wrapper(original_show, output_tracker)
    
    try:
        # Redirect stdout to capture all print statements
        with redirect_stdout(output_tracker):
            # Import and run the main script
            import TrafficViolationAnalysis
        
        # Restore original plt.show
        plt.show = original_show
        
        # Get the captured output
        captured_output = output_tracker.getvalue()
        
        # Build markdown content with figures inserted at correct positions
        md_content = f"""# Traffic Violation Analysis - Output Results

**Generated on:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

---

"""
        
        # Replace figure markers with actual image references
        import re
        figure_counter = 0
        
        def replace_figure_marker(match):
            nonlocal figure_counter
            figure_counter += 1
            fig_path = match.group(1)
            full_path = os.path.join(parent_dir, fig_path)
            if os.path.exists(full_path):
                return f"\n\n![Figure {figure_counter}]({fig_path})\n"
            return ""
        
        # Replace markers in output
        processed_output = re.sub(
            r'<!-- FIGURE_MARKER_\d+:(.+?) -->',
            replace_figure_marker,
            captured_output
        )
        
        # Add processed output
        md_content += processed_output
        
        md_content += """

---

## Notes

- This output was automatically generated by running the analysis script
- All visualizations are embedded at their generation points
- For complete results, refer to the generated plots and the Python script
"""
        
        # Write to markdown file in project root
        output_file = os.path.join(parent_dir, 'TrafficViolationAnalysis_Output.md')
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write(md_content)
        
        print(f"\nâœ“ Output successfully saved to: {output_file}")
        print(f"  Total output length: {len(captured_output)} characters")
        print(f"  Total figures saved: {len(figure_positions)}")
        if figure_positions:
            print(f"  Figure files: {', '.join(figure_positions)}")
        
        return output_file
        
    except Exception as e:
        # Restore original plt.show
        plt.show = original_show
        
        error_msg = f"Error running script: {str(e)}"
        import traceback
        error_trace = traceback.format_exc()
        print(error_msg, file=sys.stderr)
        print(error_trace, file=sys.stderr)
        
        # Create error markdown
        error_md = f"""# Traffic Violation Analysis - Output Results

**Generated on:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

## Error

{error_msg}

### Traceback

```
{error_trace}
```

## Note

The script could not be executed. Please ensure:
- All required data files are present (TrafficViolations.csv)
- All required Python packages are installed
- The script is run from the correct directory
"""
        
        output_file = os.path.join(parent_dir, 'TrafficViolationAnalysis_Output.md')
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write(error_md)
        
        return None
    finally:
        # Restore original working directory
        os.chdir(original_cwd)

if __name__ == '__main__':
    generate_markdown_output()

